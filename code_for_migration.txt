/* ENTITY  */
1.) Users Entity
@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Table(name = "users")
@EqualsAndHashCode(exclude = {"productOrders"})
public class Users implements UserDetails {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String fname;

    @Column(nullable = false)
    private String lname;

    @Column(unique = true , nullable = false)
    private String email;

    @Column(nullable = false)
    private String password;

    @Column(name = "phone_number")
    private String phoneNumber;

    @Enumerated(EnumType.STRING)
    @Column(name = "role" , nullable = false)
    private UserRoles userRoles;

    @Column(name = "reset_token")
    private String resetToken;

    @Builder.Default
    @OneToMany(mappedBy = "users" , cascade = CascadeType.ALL , orphanRemoval = true)
    private List<ProductOrder> productOrders = new ArrayList<>();

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(new SimpleGrantedAuthority(userRoles.name()));
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    @Column(name = "profile_photo")
    private String profilePicture;

    @Override
    public String toString() {
        return "Users{" +
                "id=" + id +
                ", fname='" + fname + '\'' +
                ", lname='" + lname + '\'' +
                ", email='" + email + '\'' +
                ", phoneNumber='" + phoneNumber + '\'' +
                ", userRoles=" + userRoles +
                '}';
    }
}

2.) Products
@Entity
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "product")
@EqualsAndHashCode(exclude = {"productOrders"})
public class Products {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "product_id")
    public Long id;

    @Column(name = "product_name" , nullable = false)
    public String productName;

    @Column(name = "product_desc" , length = 1000)
    public String productDesc;

    @Column(name = "inventory" , nullable = false)
    public int productInventory;

    @Column(name = "image_url")
    private String imageUrl;

    @Column(nullable = false)
    public double price ;


    @Builder.Default
    @ToString.Exclude
    @OneToMany(mappedBy = "products" , cascade = CascadeType.ALL , orphanRemoval = true)
    private List<ProductOrder> productOrders = new ArrayList<>();

    @Override
    public String toString() {
        return "Products{" +
                "productId=" + id +
                ", productName='" + productName + '\'' +
                ", productDesc='" + productDesc + '\'' +
                ", productInventory" + productInventory + '\'' +
                ", price=" + price +
                '}';
    }
}

3.) ProductOrder
@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Table(name = "product_orders")
@EqualsAndHashCode(exclude = {"users" , "products"})
public class ProductOrder {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "order_id")
    private Long orderId;

    @Column(name = "order_date" , nullable = false)
    private LocalDateTime orderDate;

    @Column(name = "estimate_delivery_date")
    private LocalDateTime estimateDeliveryDate;

    @Column(name = "delivery_date")
    private LocalDateTime deliveryDate;

    @Column(name = "order_quantity" , nullable = false)
    private int orderQuantity;

    @Enumerated(EnumType.STRING)
    @Column(name = "order_status")
    private OrderStatus orderStatus;

    @Column(name = "late_delivery_status")
    private boolean lateDeliveryStatus;

    @Column(name = "order_price" ,nullable = false)
    private double orderPrice;

    @ToString.Exclude
    @ManyToOne(optional = false , fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id" , nullable = false)
    private Users users;

    @ToString.Exclude
    @ManyToOne(optional = false , fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id" , nullable = false)
    private Products products;

    @Override
    public String toString() {
        return "ProductOrder{" +
                "orderId=" + orderId +
                ", orderDate=" + orderDate +
                ", orderQuantity=" + orderQuantity +
                ", users=" + (users != null ? users.getId() : null) +  // Optionally include user's ID
                ", products=" + (products != null ? products.getId() : null) +  // Optionally include product's ID
                '}';
    }
}

4.) OrderLog
@Entity
@Setter
@Getter
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "order_log")
public class OrderLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(optional = false , fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id")
    private Products  product;

    @ManyToOne(optional = false , fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private Users user;

    @ManyToOne(optional = false , fetch = FetchType.LAZY)
    @JoinColumn(name = "product_order_id")
    private ProductOrder productOrder;

    @Column(name = "delivered_on")
    private Date deliveredOn;

    @Column(name = "product_inventory")
    private int productInventory;

    @Column(name = "total_order_price")
    private double totalOrderPrice;
}


/* REPOSITORY  */
1.) UserRepository
@Repository
public interface UserRepository extends JpaRepository<Users, Long> {
    @Query("SELECT u FROM Users u WHERE LOWER(u.email) = LOWER(:email)")
    Optional<Users> findByEmail(@Param("email") String username);
    
    @Query("SELECT u FROM Users u WHERE LOWER(u.fname) LIKE LOWER(:name) OR LOWER(u.lname) LIKE LOWER(:name)")
    Optional<Users> findUsersByNameContaining(@Param("name") String name);
    
    Optional<Users> findByUserRoles(UserRoles userRoles);
}

2.) ProductRepository
@Repository
public interface ProductRepository extends JpaRepository<Products, Long> {
    Optional<Products> findByProductNameIgnoreCase(String productName);

    @Query("SELECT p FROM Products p ORDER BY p.price ASC")
    List<Products> findAllByOrderByPriceAsc();

    @Query("SELECT p FROM Products p ORDER BY p.price DESC")
    List<Products> findAllByOrderByPriceDesc();
}

3.) ProductOrderRepository
@Repository
public interface ProductOrderRepository extends JpaRepository<ProductOrder, Long> {
    @Query("SELECT po FROM ProductOrder po JOIN po.products p WHERE p.id = :productsId")
    List<ProductOrder> findAllProductOrderByProductId(@Param("productsId") Long productsId);
    
    @Query("SELECT po FROM ProductOrder po JOIN po.users u WHERE u.id = :userId")
    List<ProductOrder> findByUsers_Id(@Param("userId") Long userId);

    @Query("SELECT po FROM ProductOrder po JOIN po.products p WHERE p.id = :id")
    List<ProductOrder> findByProducts_Id(@Param("id") Long id);

    @Query("SELECT po FROM ProductOrder po JOIN po.users u JOIN po.products p WHERE u.id = :userId AND LOWER(p.productName) = LOWER(:productName)")
    Optional<ProductOrder> findByUserIdAndProductName(@Param("userId") Long userId , @Param("productName") String productName);

    @Query("SELECT p, COUNT(po) as orderCount FROM ProductOrder po JOIN po.products p GROUP BY p ORDER BY orderCount DESC")
    List<Object[]> findTopOrderProducts(PageRequest pageable);
}


/* SECURITY */
1.) JwtAuthenticationFilter
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Autowired
    private JwtUtil jwtUtils;

    @Autowired
    private UserServiceImpl usersDetailsService;


    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String authHeader = request.getHeader("Authorization");
        String jwt;
        String username;

        if (StringUtils.isEmpty(authHeader) || !StringUtils.startsWithIgnoreCase(authHeader , "Bearer ")){
            filterChain.doFilter(request , response);
            return;
        }

        jwt = authHeader.substring(7);
        username = jwtUtils.extractUsername(jwt);
        if ((!StringUtils.isEmpty(username)) && SecurityContextHolder.getContext().getAuthentication() == null){

            UserDetails userDetails = usersDetailsService.loadUserByUsername(username);

            if (jwtUtils.isTokenValid(jwt , userDetails)){
                SecurityContext context = SecurityContextHolder.createEmptyContext();
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(userDetails , null , userDetails.getAuthorities());
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                context.setAuthentication(authToken);
                SecurityContextHolder.setContext(context);
            }
        }
        filterChain.doFilter(request,response);
    }
}

2.) JwtUtil
@Component
public class JwtUtil {

    private final String SECRET = "5367566B59703373367639792F423F4528482B4D6251655468576D5A71347437";

    @Autowired
    private UserRepository userRepository;

    public String generateToken(String username) {
        Users user = userRepository.findByEmail(username).orElseThrow(() -> new UsernameNotFoundException("User not found"));

        Map<String,Object> claims = new HashMap<>();
        claims.put("roles" , List.of(user.getUserRoles().name()));
        return Jwts.builder()
                .claims()
                .add(claims)
                .subject(username)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis()+1000*30*60))
                .and()
                .signWith(getSigningKey())
                .compact();
    }

    private SecretKey getSigningKey() {

        byte[] keyBytes = Decoders.BASE64URL.decode(SECRET);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    public String extractUsername(String token) {
        return extractClaim(token , Claims::getSubject);
    }

    public <T> T extractClaim(String token , Function<Claims,T> claimsResolver){

        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token){
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    public boolean isTokenValid(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    private boolean isTokenExpired(String token){
        return  extractExpiration(token).before(new Date());
    }
    private Date extractExpiration(String token){
        return extractClaim(token , Claims::getExpiration);
    }

    public Users getLoggedInUser(){

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.isAuthenticated()){
            Object principal = authentication.getPrincipal();
            if (principal instanceof UserDetails userDetails){
                Optional<Users> optionalUsers = userRepository.findByEmail(userDetails.getUsername());
                return optionalUsers.orElse(null);
            }
        }
        return null;
    }

    public String getLoggedInUsername(){

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.isAuthenticated()){
            Object principal = authentication.getPrincipal();
            if (principal instanceof UserDetails userDetails){
                return userDetails.getUsername();
            }
        }
        return null;
    }
}

3.) UserServiceImpl
@Component
public class UserServiceImpl implements UserDetailsService {
    @Autowired
    private UserRepository usersRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return usersRepository.findByEmail(username).orElseThrow(() -> new UsernameNotFoundException("Username Not Found"));
    }
}

4.) WebConfig
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class WebConfig {
    @Autowired
    private UserServiceImpl userService;

    @Autowired
    private JwtAuthenticationFilter jwtAuthFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        return http
                .csrf(request -> request.disable())
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .authorizeHttpRequests(request -> request.requestMatchers("/api/auth/**").permitAll()
                        .requestMatchers("/uploads/products/**").permitAll()
                        .requestMatchers("/api/admin/**").hasAnyAuthority(UserRoles.ADMIN.name())
                        .requestMatchers("/api/user/**").hasAnyAuthority(UserRoles.USER.name())
                        .anyRequest().authenticated())
                .sessionManagement(manager -> manager.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .addFilterBefore(jwtAuthFilter , UsernamePasswordAuthenticationFilter.class)
                .build();
    }

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationProvider authenticationProvider(){
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();

        provider.setPasswordEncoder(passwordEncoder());
        provider.setUserDetailsService(userService);

        return provider;
    }

    @Bean
    public UrlBasedCorsConfigurationSource corsConfigurationSource(){
        CorsConfiguration corsConfig = new CorsConfiguration();
        corsConfig.setAllowedOrigins(Arrays.asList("http://localhost:4200"));
        corsConfig.setAllowedMethods(Arrays.asList("GET","POST" ,"PUT" , "DELETE" , "OPTION"));
        corsConfig.setAllowedHeaders(List.of("*"));
        corsConfig.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**" , corsConfig);

        return source;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) throws Exception {
        return configuration.getAuthenticationManager();
    }
}

5.) EmailConfig
@Configuration
public class EmailConfig {

        @Bean
        public JavaMailSender getJavaMailSender(){

            JavaMailSenderImpl mailSender = new JavaMailSenderImpl();

            mailSender.setHost("smtp.gmail.com");
            mailSender.setPort(587);

            mailSender.setUsername("blackplaindot@gmail.com");
            Properties properties = mailSender.getJavaMailProperties();
            properties.put("mail.transport.protocol" , "smtp");
            properties.put("mail.smtp.auth" , "true");
            properties.put("mail.smtp.starttls.enable" , "true");
            properties.put("mail.debug" , "true");

            return mailSender;

        }
}


/* MAPPER */
1.) AppMapper
@Component
@AllArgsConstructor
public class AppMapper {

    private final ProductOrderRepository orderRepository;


    public Products fromCreateProductDTO(CreateProductDTO dto){

        Products product = new Products();
        product.setProductName(dto.getProductName());
        product.setProductDesc(dto.getProductDesc());
        product.setProductInventory(dto.getProductInventory());
        product.setPrice(dto.getPrice());

        return product;
    }

    public ProductOrder fromCreateProductOrderDTO(CreateProductOrderDTO dto , Users user , Products product){

        ProductOrder order = new ProductOrder();
        order.setOrderDate(LocalDateTime.now());
        order.setEstimateDeliveryDate((dto.getEstimateDeliveryDate()));
        order.setDeliveryDate((dto.getDeliveryDate()));
        order.setOrderQuantity(dto.getOrderQuantity());
        order.setOrderStatus(OrderStatus.valueOf(dto.getOrderStatus().toUpperCase()));
        order.setOrderPrice(product.getPrice() * dto.getOrderQuantity());
        order.setUsers(user);
        order.setProducts(product);

        return order;
    }

    public ProductOrderDTO toProductOrderDTO(ProductOrder order) {
        return ProductOrderDTO.builder()
                .orderId(order.getOrderId())
                .orderDate(order.getOrderDate() != null ? Date.from(order.getOrderDate().atZone(ZoneId.systemDefault()).toInstant()) : null)
                .orderQuantity(order.getOrderQuantity())
                .estimateDeliveryDate(toDate(order.getEstimateDeliveryDate()))
                .deliveryDate(toDate(order.getDeliveryDate()))
                .userName(order.getUsers().getFname() + " " + order.getUsers().getLname())
                .userId(order.getUsers().getId())
                .productName(order.getProducts().getProductName())
                .productId(order.getProducts().getId())
                .build();
    }

    public ProductDTO toProductDTO(Products product){

        List<Long> orderIds = product
                .getProductOrders()
                .stream()
                .map(ProductOrder::getOrderId)
                .toList();

        return ProductDTO.builder()
                .productId(product.getId())
                .productName(product.getProductName())
                .productDesc(product.getProductDesc())
                .productInventory(product.getProductInventory())
                .price(product.getPrice())
                .imageUrl(product.getImageUrl())
                .productOrderIds(orderIds)
                .build();

    }

    public OrderLogInfoDTO toOrderLogInfoDTO(Users user , Products product , ProductOrder productOrder , Date deliveredOn , int productInventory , double totalOrderPrice){

        OrderLogInfoDTO dto = new OrderLogInfoDTO();

        dto.setName(user.getFname() + user.getLname());
        dto.setProductName(product.getProductName());
        dto.setOrderId(productOrder.getOrderId());
        dto.setDeliveredOn(deliveredOn);
        dto.setProductInventory(productInventory);
        dto.setTotalOrderPrice(totalOrderPrice);

        return dto;

    }

    public UserDTO toUserDTO(Users user) {
        return UserDTO.builder()
                .fname(user.getFname())
                .lname(user.getLname())
                .email(user.getEmail())
                .password(user.getPassword())
                .phoneNumber(user.getPhoneNumber())
                .userRole(user.getUserRoles())
                .build();
    }

    public UserInfoDTO toUserInfoDto(Users user){

        return UserInfoDTO
                .builder()
                .fname(user.getFname())
                .lname(user.getLname())
                .email(user.getEmail())
                .phoneNumber(user.getPhoneNumber())
                .orderIds(getAllOrderIds(user))
                .build();

    }

    public OrderLogDTO toOrderLogDto(OrderLog log , Users user , Products product){

        if (log == null){
            return null;
        }
        OrderLogDTO dto = new OrderLogDTO();
        dto.setOrderId(log.getProductOrder() != null ? log.getProductOrder().getOrderId() : null);

        Products resolvedProduct = product != null ? product : log.getProduct();
        dto.setProductName(resolvedProduct != null ? resolvedProduct.getProductName() : null);

        Users resolvedUser = user != null ? user : log.getUser();
        dto.setUserName(resolvedUser != null ? resolvedUser.getFname() + " " + resolvedUser.getLname() : null);

        ProductOrder order = log.getProductOrder();
        dto.setOrderQuantity(order != null ? order.getOrderQuantity() : 0);
        dto.setOrderPrice(order != null ? order.getOrderPrice() : 0.0);
        dto.setOrderStatus(order != null ? order.getOrderStatus() : null);
        dto.setProductInventory(log.getProductInventory());
        dto.setOrderQuantity(order != null ? order.getOrderQuantity() : 0);

        return dto;
    }

        public OrderProductListDTO toOrderProductListDTO(ProductOrder order){

        return new OrderProductListDTO(
                order.getProducts().getProductName(),
                order.getProducts().getPrice(),
                order.getOrderQuantity()
        );

    }

        public Date toDate(LocalDateTime localDateTime){
                return localDateTime != null ? Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()) : null;
    }

    public LocalDateTime toLocalDateTime(Date date){
        return date != null ? date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime() : null;
    }
}


/* DTO */
1.) AuthenticationRequest
@Data
public class AuthenticationRequest {
    private String email;
    private String password;
}

2.) AuthenticationResponse
@Data
public class AuthenticationResponse {

    private Long userId;
    private String jwt;
    private String fullName;
    private UserRoles userRoles;
}

3.) ForgotPasswordRequest
@Data
public class ForgotPasswordRequest {
        private String email;
}

4.) ResetPasswordRequest
@Data
public class ResetPasswordRequest {
    private String email;
    private String token;
    private String newPassword;
}

5.) SignUpData
@Data
public class SignUpDTO {
    private String fname;
    private String lname;
    private String email;
    private String password;
    private String phoneNumber;
}

6.) UserDTO
@Data
public class UserDTO {
    private Long id;
    private String fname;
    private String lname;
    private String email;
    private String username;
    private String password;
    private String phoneNumber;
    private UserRoles userRole;
}


/* CONTROLLER */
1.) AuthController
@RestController
@RequestMapping("/api/auth")
@CrossOrigin("*")
public class AuthController {

    @Autowired
    private AuthService authService;

    @Autowired
    private UserRepository userRepository;

    @PostMapping("/signup")
    public ResponseEntity<?> signUpUser(@RequestBody SignUpDTO signUpDTO){

        if (authService.hasUserWithEmail(signUpDTO.getEmail())){

            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body(null);
        }
        UserDTO user = authService.signupUser(signUpDTO);

        if (user == null){
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("User Not Created");
        }else return ResponseEntity.status(HttpStatus.CREATED).body(user);
    }

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private UserServiceImpl userService;

    @Autowired
    private AuthenticationManager authenticationManager;

    @PostMapping("/login")
    public ResponseEntity<AuthenticationResponse> login (@RequestBody AuthenticationRequest authenticationRequest){

        try{
            authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(authenticationRequest.getEmail() , authenticationRequest.getPassword()));
        }catch (BadCredentialsException ex){
            throw new BadCredentialsException("Incorrect username or Password");
        }

        UserDetails userDetails = userService.loadUserByUsername(authenticationRequest.getEmail());
        Optional<Users> optionalUser = userRepository.findByEmail(authenticationRequest.getEmail());
        String jwtToken = jwtUtil.generateToken(optionalUser.get().getUsername());
        AuthenticationResponse authenticationResponse = new AuthenticationResponse();
        if (optionalUser.isPresent()) {
            authenticationResponse.setJwt(jwtToken);
            authenticationResponse.setUserId(optionalUser.get().getId());
            authenticationResponse.setFullName(optionalUser.get().getFname() + optionalUser.get().getLname());
            authenticationResponse.setUserRoles(optionalUser.get().getUserRoles());
        }

        return ResponseEntity.status(HttpStatus.ACCEPTED).body(authenticationResponse);
    }

    @PostMapping("/upload-profile-picture/{userId}")
    public ResponseEntity<?> uploadProfilePicture(
            @PathVariable Long userId,
            @RequestParam("file") MultipartFile file) {
        String filename = authService.updateProfilePicture(userId, file);
        return ResponseEntity.ok("Profile picture uploaded: " + filename);
    }

    @PostMapping("/forgot-password")
    public ResponseEntity<?> forgotPassword(@RequestBody ForgotPasswordRequest forgotPasswordRequest){
        authService.sendResetToken(forgotPasswordRequest.getEmail());
        return ResponseEntity.ok("Reset token sent to email");
    }

    @PostMapping("/reset-password")
    public ResponseEntity<?> resetPassword(@RequestBody ResetPasswordRequest resetPasswordRequest){

        authService.resetPassword(
                resetPasswordRequest.getEmail(),
                resetPasswordRequest.getToken(),
                resetPasswordRequest.getNewPassword()
        );
        return ResponseEntity.ok("Password reset successful");
    }
}


/* SERVICES */
1.) AuthService
@Service
public class AuthService {

    @Autowired
    private UserRepository userRepository;
    @Autowired
    private UserServiceImpl userService;
    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private EmailService emailService;

    @Autowired
    private AppMapper mapper;

    @Value("${file.user-upload-dir}")
    private String uploadDir;

    @PostConstruct
    public void  createAdmin(){

        try {
            Optional<Users> optionalUsers = userRepository.findByUserRoles(UserRoles.ADMIN);

            if (optionalUsers.isEmpty()) {

                Users users = new Users();

                users.setFname("Admin F");
                users.setLname("Admin L");
                users.setEmail("admin@test.com");
                users.setPassword(new BCryptPasswordEncoder().encode("password"));
                users.setPhoneNumber("0000000000");
                users.setUserRoles(UserRoles.ADMIN);
                users.setProductOrders(null);
                users.setProfilePicture(null);
                userRepository.save(users);

                System.out.println("Admin created successfully");
            } else {
                System.out.println("Admin already created");
            }
        }catch(Exception ex){
            System.err.println("Failed to initialize admin: " + ex.getMessage());
        }
    }

    public UserDTO signupUser(SignUpDTO signUpDTO){
        try {
            Users users = new Users();

            users.setFname(signUpDTO.getFname());
            users.setLname(signUpDTO.getLname());
            users.setEmail(signUpDTO.getEmail());
            users.setPassword(new BCryptPasswordEncoder().encode(signUpDTO.getPassword()));
            users.setPhoneNumber(signUpDTO.getPhoneNumber());
            users.setUserRoles(UserRoles.USER);
            users.setProfilePicture(null);
            Users createdUsers = userRepository.save(users);

            return mapper.toUserDTO(createdUsers);
        }catch(Exception ex){
            throw new UsernameNotFoundException("Failed to signup user: " + ex.getMessage());
        }
    }

    public String updateProfilePicture(Long userId , MultipartFile file){
        try{
            Users users = userRepository.findById(userId).orElseThrow(() -> new UsernameNotFoundException("User not found"));

            String filename = UUID.randomUUID() + "_" + file.getOriginalFilename();
            Path filePath = Paths.get(uploadDir , filename);

            Files.createDirectories(filePath.getParent());
            Files.write(filePath , file.getBytes());

            users.setProfilePicture(filename);
            userRepository.save(users);

            return filename;
        } catch (IOException e) {
            throw new RuntimeException("Failed to upload profile picture: " + e.getMessage());
        }
    }

    public boolean hasUserWithEmail(String username){
        try {
            return userRepository.findByEmail(username).isPresent();
        }catch(Exception ex){
            throw new UserWithEmailNotFoundException("Failed to check user existence by email: " + ex.getMessage());
        }
    }

    public void sendResetToken(String email){
        try {
            Users users = userRepository.findByEmail(email).orElseThrow(() -> new UsernameNotFoundException("User with email " + email + " not found"));
            String resetToken = jwtUtil.generateToken(email);
            users.setResetToken(resetToken);
            userRepository.save(users);

            String resetLink = "http://localhost:4200/reset-password?token=" + resetToken;
            emailService.sendEmail(email, "Password Reset", "Click the reset your password : " + resetLink);
        }catch(UsernameNotFoundException ex){
            throw ex;
        }catch (Exception ex){
            throw new PasswordResetTokenException("Failed to send reset token: " + ex.getMessage());
        }
    }

    public boolean validateResetToken(String token , String email){
        try {
            String extractedEmail = jwtUtil.extractUsername(token);

            if (!extractedEmail.equals(email)) {
                return false;
            }

            UserDetails userDetails = userService.loadUserByUsername(email);

            return jwtUtil.isTokenValid(token, userDetails);
        }catch(Exception ex){
            throw new PasswordResetTokenException("Failed to reset password: " + ex.getMessage());
        }
    }

    public String resetPassword(String email , String token , String newPassword){
        try {
            if (!validateResetToken(token, email)) {
                throw new ExpiredTokenException("Invalid or expired token");
            }

            Users users = userRepository.findByEmail(email).orElseThrow(() -> new UsernameNotFoundException("User not found"));

            users.setPassword(new BCryptPasswordEncoder().encode(newPassword));
            userRepository.save(users);

            return "Password reset successful";
        }catch (IllegalArgumentException | UsernameNotFoundException ex){
            throw ex;
        }catch (Exception ex){
            throw new PasswordResetTokenException("Failed to reset password: " + ex.getMessage());
        }
    }
}

2.) EmailService
@Service
public class EmailService {
    @Autowired
    private JavaMailSender mailSender;

    public void sendEmail(String to , String subject , String body){

        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(to);
        message.setSubject(subject);
        message.setText(body);

        try{
            mailSender.send(message);
            System.out.println("Email sent successfully to : " + to);

        }catch (Exception ex){
            System.out.println("Error sending email " + ex.getMessage());
        }

    }
}